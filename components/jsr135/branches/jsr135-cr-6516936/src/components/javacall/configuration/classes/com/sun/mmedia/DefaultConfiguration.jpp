/*
 *
 * Copyright  1990-2006 Sun Microsystems, Inc. All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version
 * 2 only, as published by the Free Software Foundation. 
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License version 2 for more details (a copy is
 * included at /legal/license.txt). 
 * 
 * You should have received a copy of the GNU General Public License
 * version 2 along with this work; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA 
 * 
 * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
 * Clara, CA 95054 or visit www.sun.com if you need additional
 * information or have any questions. 
 */
package com.sun.mmedia;

import javax.microedition.media.Manager;
import com.sun.midp.log.Logging;
import com.sun.midp.log.LogChannels;
import java.util.Vector;
import java.util.Hashtable;
import java.util.Enumeration;

/**
 *  The default configuration module for an MMAPI.
 *  implementation supporting the http and
 *  device protocols as well as the following
 *  content types:
 *
 *      Tones,
 *      Tone Sequences,
 *      AMR Narrowband
 *      AMR Wideband.
 *      GIF.
 *
 *  Please note:
 *
 *  Tone Sequences are supported over http in tone sequence
 *  file format (.jts).
 *
 *  Both single tones and tone sequence are also supported
 *  over the device protocol.
 *
 */
public class DefaultConfiguration extends Configuration {

    // #ifdef ENABLE_DEBUG [
    private boolean debug = true;
    // #else ][
    private boolean debug = false;
    // #endif ]

	private Hashtable protocolsOfContent;
	private Hashtable contentsOfProtocol;
	private Hashtable mimetypeOfLocator;
	
    /**
     * Tone sequence mime type.
     */
    public final static String MIME_AUDIO_TONE = "audio/x-tone-seq";

    /**
     * MIME_AUDI_AMR NB mime type.
     */
    public final static String MIME_AUDIO_WAV = "audio/x-wav";
    public final static String MIME_AUDIO_WAV_2 = "audio/wav";    

    /**
     * MIME_AUDI_AMR WB mime type.
     */
    public final static String MIME_AUDIO_AMR_WB = "audio/amr-wb";

    /**
     * MIME_AUDI_AMR mime type
     */
    public final static String MIME_AUDIO_AMR = "audio/amr";

    /**
     * GIF mime type.
     */
    public final static String MIME_IMAGE_GIF = "image/gif";

    /**
     * PNG mime type.
     */
    public final static String MIME_IMAGE_PNG = "image/png";

    /**
     * JPEG mime type.
     */
    public final static String MIME_IMAGE_JPEG = "image/jpeg";

    /**
     * Raw image mime type.
     */
    public final static String MIME_IMAGE_RAW = "image/raw";

    /**
     * MIME_AUDIO_MIDI mime type.
     */
    public final static String MIME_AUDIO_MIDI = "audio/midi";
    public final static String MIME_AUDIO_MIDI_2 = "audio/mid";

    /**
     * SP-MIME_AUDIO_MIDI mime type.
     */
    public static final String MIME_AUDIO_SP_MIDI = "audio/sp-midi";

    /**
     * MIME_AUDIO_MP3 mime type
     */
    public final static String MIME_AUDIO_MP3 = "audio/mpeg";
    public final static String MIME_AUDIO_MP3_2 = "audio/mp3";

    /**
     * MP4 audio type
     */
    public final static String MIME_AUDIO_MP4 = "audio/mp4";
    public final static String MIME_AUDIO_MP4_2 = "audio/mp4a-latm";

    /**
     * MIME_AUDIO_AAC audio type
     */
    public final static String MIME_AUDIO_AAC = "audio/aac";

    /**
     * MIME_AUDIO_QCELP audio type
     */
    public final static String MIME_AUDIO_QCELP = "audio/qcelp";
    public final static String MIME_AUDIO_QCELP_2 = "audio/vnd.qcelp";

    /**
     * 3GPP video mime type
     */
    public final static String MIME_VIDEO_3GPP = "video/3gpp";
    public final static String MIME_VIDEO_3GPP_2 = "video/3gpp2";

    /**
     * MPEG video mime type
     */
    public final static String MIME_VIDEO_MPEG = "video/mpeg";

    /**
     * MPEG4 video mime type
     */
    public final static String MIME_VIDEO_MPEG4 = "video/mp4";

	protected final static String DIRECT_TONE_CLASS = "com.sun.mmedia.DirectTone";
	protected final static String DIRECT_MIDI_CLASS = "com.sun.mmedia.DirectMIDI";
	protected final static String DIRECT_PLAYER_CLASS = "com.sun.mmedia.DirectPlayer";
	protected final static String DIRECT_VIDEO_CLASS = "com.sun.mmedia.DirectVideo";
	protected final static String DIRECT_CAMERA_CLASS = "com.sun.mmedia.DirectCamera";
	protected final static String GIFPLAYER_CLASS = "com.sun.mmedia.GIFPlayer";
	
    public final static String TONE_DEVICE_LOCATOR = javax.microedition.media.Manager.TONE_DEVICE_LOCATOR; //"device://tone";
    public final static String MIDI_DEVICE_LOCATOR = javax.microedition.media.Manager.MIDI_DEVICE_LOCATOR; //"device://midi";
    public final static String RADIO_CAPTURE_LOCATOR = "capture://radio";
    public final static String AUDIO_CAPTURE_LOCATOR = "capture://audio";
    public final static String VIDEO_CAPTURE_LOCATOR = "capture://video";
    public final static String TONE_DEVICE_LOCATOR = "device://tone";
    public final static String MIDI_DEVICE_LOCATOR = "device://midi";
        	
    protected final static String maps[][] = {
        {Manager.TONE_DEVICE_LOCATOR, DIRECT_TONE_CLASS},
    // #ifdef MIDI_CONTROL [
        {Manager.MIDI_DEVICE_LOCATOR, DIRECT_MIDI_CLASS},
    // #endif ]
        {MIME_AUDIO_TONE, DIRECT_PLAYER_CLASS},
        {MIME_AUDIO_AMR, DIRECT_PLAYER_CLASS},
        {MIME_AUDIO_WAV, DIRECT_PLAYER_CLASS},
        {MIME_AUDIO_WAV_2, DIRECT_PLAYER_CLASS},
        {MIME_AUDIO_MIDI, DIRECT_PLAYER_CLASS},
        {MIME_AUDIO_MIDI_2, DIRECT_PLAYER_CLASS},
    // #ifndef ABB [
        {MIME_AUDIO_MP3, DIRECT_PLAYER_CLASS},
        {MIME_AUDIO_MP3_2, DIRECT_PLAYER_CLASS},
        {MIME_AUDIO_MP4, DIRECT_PLAYER_CLASS},
        {MIME_AUDIO_MP4_2, DIRECT_PLAYER_CLASS},
        {MIME_AUDIO_AAC, DIRECT_PLAYER_CLASS},
        {MIME_AUDIO_QCELP, DIRECT_PLAYER_CLASS},
        {MIME_AUDIO_QCELP_2, DIRECT_PLAYER_CLASS},
        {MIME_VIDEO_3GPP, DIRECT_VIDEO_CLASS},
        {MIME_VIDEO_3GPP_2, DIRECT_VIDEO_CLASS},
        {MIME_VIDEO_MPEG, DIRECT_VIDEO_CLASS},
        {MIME_VIDEO_MPEG4, DIRECT_VIDEO_CLASS},
// #ifdef ENABLE_INDIRECT_VIDEO [        
        {MIME_IMAGE_GIF, GIFPLAYER_CLASS},
// #endif ]        
        {VIDEO_CAPTURE_LOCATOR, DIRECT_CAMERA_CLASS},
        {AUDIO_CAPTURE_LOCATOR, DIRECT_PLAYER_CLASS},
    // #endif ]
    };

// #ifdef ENABLE_INDIRECT_VIDEO [
    /**
     *  Handle for the Image Access Environment...
     */
    private static ImageAccess imageAccessor;
// #endif ]

	private void addPairToHash(Hashtable hash, Object key, Object nValue) {
		Vector vct = (Vector)hash.get(key);
		if (vct == null) {
			vct = new Vector(2);
			vct.addElement(nValue);
			hash.put(key, vct);
		} else {
			if (vct.indexOf(nValue) == -1)
				vct.addElement(nValue);
		}
	}
	
	private void addProtocolContentPair(String protocol, String contentType) {
	// #ifndef ENABLE_FILE_CONNECTION_SUPPORT
		if (protocol.equals("file"))
			return;
	// #endif		
		addPairToHash(protocolsOfContent, contentType, protocol);
		addPairToHash(contentsOfProtocol, protocol, contentType);
	}
	
	private void trimProtocolContentPairs() {
		for (int i = 0; i < 2; i++) {
			Enumeration e;
			if (i == 0)
				e = protocolsOfContent.elements();
			else 
				e = contentsOfProtocol.elements();
			for (; e.hasMoreElements();) {
				Vector vct = (Vector)e.nextElement();
				vct.trimToSize();
			}
		}
	}

	// #ifdef USE_NATIVE_CONFIG
		private native String[][] nGetMediaCaps();
	// #endif
	
	private void initHashtables() {
		if (protocolsOfContent == null) {
			protocolsOfContent = new Hashtable();
			contentsOfProtocol = new Hashtable();
			mimetypeOfLocator = new Hashtable();
			
		// #ifdef USE_NATIVE_CONFIG
			String[][] res = nGetMediaCaps();
			if (res != null) {
				for (int i = 0; i < res.length; i++) {
					for (int j = 1; j < res[i].length; j++)
						addProtocolContentPair(res[i][j], res[i][0]);
				}
			}
			
			mimetypeOfLocator.add(Manager.TONE_DEVICE_LOCATOR, 
				DefaultConfiguration.MIME_AUDIO_TONE);
			mimetypeOfLocator.add(Manager.MIDI_DEVICE_LOCATOR, 
				DefaultConfiguration.MIME_AUDIO_TONE);
			mimetypeOfLocator.add(Configuration.AUDIO_CAPTURE_LOCATOR, 
				DefaultConfiguration.MIME_AUDIO_WAV);
			mimetypeOfLocator.add(Configuration.VIDEO_CAPTURE_LOCATOR, 
				DefaultConfiguration.MIME_IMAGE_PNG);
		// #endif
		
			addProtocolContentPair(MIME_IMAGE_GIF, "file");
			addProtocolContentPair(MIME_IMAGE_GIF, "http");
		
			trimProtocolContentPairs();
		}
	}
	
    /**
     *Constructor for the DefaultConfiguration object
     */
    public DefaultConfiguration() {
        super();


		initHashtables();
		
        // Protocol handlers.
        handlers.put("http", "com.sun.mmedia.protocol.CommonDS");
    // #ifdef ENABLE_FILE_CONNECTION_SUPPORT [
        handlers.put("file", "com.sun.mmedia.protocol.CommonDS");
    // #endif
        handlers.put("rtsp", "com.sun.mmedia.protocol.CommonDS");
        
        // Content handlers.
        for (int i = 0; i < maps.length; ++i) {
            handlers.put(maps[i][0], maps[i][1]);
        }

        // Mime types
        mimeTypes.put("jts", MIME_AUDIO_TONE);
        mimeTypes.put("mid", MIME_AUDIO_MIDI);
        mimeTypes.put("midi", MIME_AUDIO_MIDI);
        mimeTypes.put("kar", MIME_AUDIO_MIDI);
        mimeTypes.put("wav", MIME_AUDIO_WAV);
        mimeTypes.put("mp3", MIME_AUDIO_MP3);
        mimeTypes.put("m4a", MIME_AUDIO_MP4);
        mimeTypes.put("qcp", MIME_AUDIO_QCELP);
        mimeTypes.put("aac", MIME_AUDIO_AAC);
        mimeTypes.put("amr", MIME_AUDIO_AMR);
        mimeTypes.put("3gp", MIME_VIDEO_3GPP);
        mimeTypes.put("mpg", MIME_VIDEO_MPEG);
        mimeTypes.put("mp4", MIME_VIDEO_MPEG4);
        mimeTypes.put("gif", MIME_IMAGE_GIF);

        // for converting
        mimeTypes.put("audio/tone", MIME_AUDIO_TONE);

    // #ifdef ENABLE_JSR_234 [
        // for Image Access we need to init some environment values...
        //imageAccessor = (ImageAccess)createInstanceOf("com.sun.mmedia.ImageAccess");
        imageAccessor = new MIDPImageAccessor();

        // Media Processors.
        processors.put(MIME_IMAGE_RAW, "com.sun.amms.imageprocessor.ObjectImageProcessor");
        processors.put(MIME_IMAGE_JPEG, "com.sun.amms.imageprocessor.StreamImageProcessor");
        processors.put(MIME_IMAGE_PNG, "com.sun.amms.imageprocessor.StreamImageProcessor"); 
    // #endif ]
        
    }

	private String[] getSupportedValues(Hashtable bsOfA, Hashtable asOfB, String Avalue) {
		String[] res;
        if (Avalue == null) {
			 res = new String[asOfB.size()];
			int count = 0;
			for (Enumeration e = asOfB.keys(); e.hasMoreElements();) {
				String val = (String)e.nextElement();
				res[count++] = val;
			}
		
        } else {
			Vector vct = (Vector)bsOfA.get(Avalue);
			if (vct != null) {
				res = new String[vct.size()];
				vct.copyInto(res);
			} else {
				res = new String[0];
			}
        }
		return res;
	}
	
    /**
     *  Gets the supportedContentTypes attribute of the DefaultConfiguration object
     *
     * @param  protocol  Description of the Parameter
     * @return           The supportedContentTypes value
     */
    public String[] getSupportedContentTypes(String protocol) {
		return getSupportedValues(contentsOfProtocol, protocolsOfContent, protocol);
    }

    /**
     * Get content type helper function
     */
    public static String getContentType(String locator) {
        if ((locator != null) && (mimetypeOfLocator != null)) {
			String val = (String) mimetypeOfLocator.get(locator);
			return val;
        }
        
        return "";
    }

    /**
     *  Gets the supportedProtocols attribute of the DefaultConfiguration object
     *
     * @param  content_type  Description of the Parameter
     * @return               The supportedProtocols value
     */
    public String[] getSupportedProtocols(String content_type) {
        if (debug) {
            Logging.report(Logging.INFORMATION, LogChannels.LC_MMAPI,
                "getSupportedProtocols : " + content_type);
        }

		return getSupportedValues(protocolsOfContent, contentsOfProtocol, content_type);
    }

    public ImageAccess getImageAccessor() {
    // #ifdef ENABLE_INDIRECT_VIDEO [
        return imageAccessor;
    // #else ][
        return null;
    // #endif ]
    }

// #ifdef ENABLE_JSR_234 [
    public String[] getSupportedMediaProcessorInputTypes() {
        return new String[] {MIME_IMAGE_PNG, MIME_IMAGE_JPEG, MIME_IMAGE_RAW};
    }

    public String[] getSupportedSoundSource3DPlayerTypes() {
        return new String[] {MIME_AUDIO_WAV};
    }
// #endif ]    

    /**
     * Gets the video renderer.
     *
     * @return The video renderer
     */
    public VideoRenderer getVideoRenderer(BasicPlayer player, 
                                          int sourceWidth, 
                                          int sourceHeight) {
    // #ifdef ENABLE_INDIRECT_VIDEO [                                          
        return new MIDPVideoRenderer(player, sourceWidth, sourceHeight);
    // #else ][
        return null;
    // #endif ]
    }

    /**
     *  Gets the tonePlayer attribute of the DefaultConfiguration object
     *
     * @return    The tonePlayer value
     */
    public TonePlayer getTonePlayer() {
        return new NativeTonePlayer();
    }
    
    //public MIDIRenderer getMIDIRenderer() 
    //{
    //    return null;
    //}

    public String getProperty(String key) {
        String value = (String) properties.get(key);
        return value;
    } 

    public void setProperty(String key, String value) {
        properties.put(key, value);
    }       

    private Object createInstanceOf(String propertyName) {
        try {
            String propertyValue = getProperty(propertyName);
            Class propertyClass = Class.forName(propertyValue);
            Object propertyInstance = propertyClass.newInstance();
            return propertyInstance;
        } catch (Exception e) {
            return null;
        }
    }
}
