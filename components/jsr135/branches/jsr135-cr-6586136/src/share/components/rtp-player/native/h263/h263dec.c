/*-----------------------------------------------------------------------------
 *  H263DEC.C
 *
 *  DESCRIPTION
 *      h263dec.c - Functions for H.263 decoding
 *      The file contains the following external functions:
 *          DecPicLayer263 - Decode H.263 Picture Layer information
 *          InitMvTabs - Initialize tables for mvB/mvF (mv for B-frame)
 *          DecGobLayer263 - Decode H.263 GOB Layer information
 *          DecMbLayer263 - Decode macroblock layer and block layer for a Group Of Blocks
 *          GetMvBframe - Reconstruct forward and backward motion vectors for B-frame
 *          H263RtpDecode - Decode an RTP packet according to RFC2190 (Sept'97)
 *          H263ConcealRest - Repeat remainder of picture (called if last bitstream packet
 *                            for picture got lost or corrupted)
 *
 *      Author:     Staffan Ericsson    7/10/95
 *      Inspector:  <not inspected yet>
 *      Revised:
 *      01/03/98    se  RTP support for H.263: added H263RtpDecode and H263ConcealRest;
 *                      modified DecMbLayer263
 *      03/21/97    se  Modify Reduced-Res Update mode to 2/97 draft spec
 *      02/10/97    db  Support for decoding H.263+ bitstreams
 *      01/23/97    se  Reduced-Resolution Update mode
 *      11/03/96    se  Support PB-frames
 *      07/21/96    se  Support ANYSIZE
 *      06/02/96    se  Support UMV mode (+/- 31.5 pixel motion vectors)
 *      04/11/96    se  Update Picture Layer to final H.263 spec.
 *      12/18/95    md	Remove "#include vvenc.h"
 *      11/10/95    se  Clip "quant + DQUANT" to [1,31]. 
 *      11/10/95    se  INTRA blocks in PB frames contain MVDB if indicated by MODB.  
 *      11/09/95    md  PTYPE is 13 bits (November 1995 spec.)  
 *  
 *  (c) 1995-1998, Vivo Software, Inc.  All rights reserved 
 -----------------------------------------------------------------------------*/ 

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "dllindex.h"
#include "h261defs.h"
#include "vldstate.h"
#include "vldtabs.h"
#include "h261func.h"
#include "vldecode.h"       /* set the proper pragmas for VLDecode          */
#include "h263plus.h"

#define RTP_SUPPORT

//#define BS_ERR_MSG(a)   a   // Generate messages on bitstream error (i.e., illegal 
                            // bitstream syntax) to simplify debugging
#define BS_ERR_MSG(a)     // Suppress error messages 

//#define CHECKSYM(a)     a     // Check symbol types to verify decoder state tables
#define CHECKSYM(a)            // Don't check symbol types

////////////  Static function declarations  ////////////
//  initPBtabs - Initialize tables for Bquant and mvB/mvF
static void initPBtabs( PICTURE_DESCR * pic );
//  decMvd - Decode "num" motion vectors
static int  decMvd( BS_PTR * bs,    // Bitstream pointer; updated by this routine
                    int * maxBits,  // max bits to decode; updated by this routine
                    int num,        // number of motion vectors to decode
                    S8  x[],        // hor. components decoded by this routine
                    S8  y[]         // vert. components decoded by this routine
                    );
// getMvComp - Compute mv component in H.263 decoder
static int getMvComp( int pred, S8 diff, int unrestrictedMv );
//  dec263blocks - Decode block layer for a macroblock
static int  dec263blocks(   BS_PTR * bs,    // Bitstream pointer; updated by this routine
                            int * maxBits,  // max bits to decode; updated by this routine
                            int cbp,        // Coded Block Pattern
                            int intraFlag,  // 0: INTER block, otherwise INTRA
                            int advancedIntraMode, // 0: off else on
                            BLOCK_DESCR block[6],   // block descriptors generated by this routine
                            SYMBOL sym[],   // array for symbols generated by this routine
                            int maxsym      // size of sym[] array
                            );
//  parseSymbols - Create block descriptor and merge ESC-RUN and ESC-LEVEL symbols
//  Return number of symbols
static int parseSymbols( SYMBOL insym[],        // Input symbols
                        int nsym,               // # input symbols
                        SYMBOL outsym[]         // output symbols
                        );
#ifdef RTP_SUPPORT
// rtpDecPicHdr - Decode Picture Layer info from bitstream or payload header
static int rtpDecPicHdr( H261Decoder * s, char * hdr );
// rtpDec1998PicHdr - Decode Picture Layer info from bitstream or payload header
static int rtpDec1998PicHdr( H261Decoder * s, char * hdr );
// picPayloadHdr - Decode Picture Layer info from payload header
static int picPayloadHdr( H261Decoder * s, char * hdr );
// pic1998PayloadHdr - Decode Picture Layer info from payload header
static int pic1998PayloadHdr( H261Decoder * s, char * hdr );
// getGnMbaFromPacket - Get GOB number and macroblock address from payload header
static int getGnMbaFromPacket( H261Decoder * s, char * hdr, int *gn, int *mba );
static int getGnMbaFrom1998Packet( H261Decoder * s, char * hdr, int *gn, int *mba );
// rtpConceal- Conceal missing MBs from s->next_gob/mba to gn/mba
static int rtpConceal( H261Decoder * s, int gn, int mba );
// gobPayloadHdr - Get QUANT and MV from payload header
static int gobPayloadHdr( H261Decoder * s, char * hdr, int gn, int mba );
// rtpDecMbLayer - Try to decode (rest of) GOB
static int rtpDecMbLayer( H261Decoder * s, int *mba, int h263_1998 );
// rtpReconGob - Reconstruct decoded MBs
static void rtpReconGob( H261Decoder * s, int mba );
// numGobs - Return number of GOBs in picture
static int numGobs( int format );
#endif  /* RTP_SUPPORT */



//  DecPicLayer263 - Decode H.263 Picture Layer information
extern int  DecPicLayer263( BS_PTR * bs, int nbits, PICTURE_DESCR * pic,
                            GOB_DESCR * gob, int * decPtype )
{
    int     gn, tr, ptype, quant, pei, pspare, cpm;
#ifdef DO_H263_PLUS
    int eptype=0;
#endif
    // Decode GN
    if (FLDecSymbol( bs, 5, &nbits, &gn )  !=  OK)  return( OUT_OF_BITS );
    if (gn != 0)  return( H261_ERROR );     // GN=0 for Picture Start Code
    // Decode TR
    if (FLDecSymbol( bs, 8, &nbits, &tr )  !=  OK)  return( OUT_OF_BITS );
    pic->tr = tr;
    // Decode PTYPE
    if (FLDecSymbol( bs, 13, &nbits, &ptype )  !=  OK)  return( OUT_OF_BITS );

#ifdef DO_H263_PLUS
    if ((ptype & 0xe0) == PTYPE263_EPTYPE) {
        if(FLDecSymbol( bs, 14, &nbits, &eptype )  !=  OK)  return( OUT_OF_BITS );
        // the picture type is in bits 1-3 of EPTYPE, put those bits into bits 6-8 of PTYPE
        ptype &= 0xFFFFFF1F; // clear bits 6-8
        ptype |= (0x3800 & eptype) >> 6; 
    }
#endif

    pic->ptype = ptype;
    *decPtype = ptype;
    pic->splitscreen = ptype & PTYPE263_SPLITSCREEN;
    pic->doccamera = ptype & PTYPE263_DOCCAMERA;
    pic->fp_release = ptype & PTYPE263_FP_RELEASE;
    switch (ptype & 0xe0)
    {
    case PTYPE263_SQCIF:
        pic->format = SQCIF;
        break;
    case PTYPE263_QCIF:
        pic->format = QCIF;
        break;
    case PTYPE263_CIF:
        pic->format = CIF;
        break;
    case PTYPE263_4CIF:
        pic->format = CIF4;
        break;
    case PTYPE263_16CIF:
        pic->format = CIF16;
        break;
    case PTYPE263_RESERVED:
        pic->format = ANYSIZE;
        break;
    default:
        return( H261_ERROR );
        break;
    }
    if ((ptype & 0x800) != 0  || (ptype & 0x1000) == 0) return( H261_ERROR );
    pic->interFrame = ptype & PTYPE263_INTER;
    pic->unrestrictedMv = ptype & PTYPE263_UNRESTRICTED_MV;
    pic->advancedPred = ptype & PTYPE263_ADVANCED_PRED;
    pic->syntax_basedAC = ptype & PTYPE263_SYNTAX_BASED_AC;
    if (pic->syntax_basedAC) {
        BS_ERR_MSG( H261ErrMsg("Syntax-based AC not yet supported"); )
        return( H261_ERROR );
    }
    pic->PBframeMode = (ptype & PTYPE263_PB_FRAME) != 0;

#ifdef DO_H263_PLUS
    // Do PB frame - either orignal or improved mode
    pic->PBframeMode = (ptype & PTYPE263_PB_FRAME) ? 1 : 0;
    if(pic->PBframeMode) {
        if( eptype & EPTYPE263PLUS_IMPROVED_PBFRAME_MODE) {
            pic->PBframeMode = H263PLUS_IMPROVED_PBFRAME_MODE;
        }
    } else {
        if( eptype & EPTYPE263PLUS_IMPROVED_PBFRAME_MODE) {
            return ( H261_ERROR );
        }
    }
    // Are deblocking filters on?
    pic->deblockingFilterMode = eptype & EPTYPE263PLUS_DEBLOCKING_FILTER_MODE;
    // Use advanced intra mode?
    pic->advancedIntraMode = eptype & EPTYPE263PLUS_ADVANCED_INTRA_MODE;
    // Using Reduced-resolution Update mode?
    pic->reducedResUpdate = eptype & EPTYPE263PLUS_REDUCED_RES_UPDATE;
    //if (pic->reducedResUpdate && (!pic->interFrame || pic->PBframeMode)) return( H261_ERROR );
#else
    pic->reducedResUpdate = 0;
#endif

    if(pic->interFrame == 0 && pic->PBframeMode != 0) return( H261_ERROR );
    // Decode PQUANT
    if (FLDecSymbol( bs, 5, &nbits, &quant )  !=  OK)  return( OUT_OF_BITS );
    if (quant < QUANT_MIN  ||  quant > QUANT_MAX)  return( H261_ERROR );
    gob->gquant = quant;
     // Decode CPM (continuous presence multipoint). For now, flag error if not zero.
    if (FLDecSymbol( bs, 1, &nbits, &cpm )  !=  OK)  return( OUT_OF_BITS );
    if (cpm != 0)  return( H261_ERROR );
    pic->cpm = cpm;     // Save (we may need it?)
    if (pic->PBframeMode) {
        // Decode TRB
        if (FLDecSymbol( bs, 3, &nbits, &tr )  !=  OK)  return( OUT_OF_BITS );
        pic->tempRefBframe = tr;
        // Decode DBQUANT
        if (FLDecSymbol( bs, 2, &nbits, &quant )  !=  OK)  return( OUT_OF_BITS );
        pic->dbQuant = quant;
        initPBtabs( pic );  // Generate lookup tables for Bquant and mvB/mvF
    }
    pic->trPrev = pic->tr;  // Hold on to TR for decoding of next picture
    // Decode PEI
    if (FLDecSymbol( bs, 1, &nbits, &pei )  !=  OK)  return( OUT_OF_BITS );
    pic->peiCount = 0;
    // Decode PSPARE
    while (pei) {   // Loop until PEI=0
        if (pic->peiCount < MAX_PEI_COUNT) {
            FLDecSymbol( bs, 8, &nbits, &pspare );
            pic->pSpare[pic->peiCount] = pspare;
        } else {
            ++bs->byteptr;  // Drop PSPARE on the floor
        }
        ++pic->peiCount;
        if (FLDecSymbol( bs, 1, &nbits, &pei )  !=  OK)  return( OUT_OF_BITS );
    }
    // Indicate that GOB header has no "spares"
    gob->gei = 0;
    gob->num_gspare = 0;
    return( OK );
}


//  InitMvTabs - Initialize tables for mvB/mvF
extern void InitMvTabs( int trD, int trB,
                        int tabMvF[], int tabMvB[]  // [UMV_MIN:UMV_MAX]
                        )
{
    int i;

    // Generate tables for B-picture motion vectors
    trD &= H263_TR_MASK;
    if (trD == 0)  trD = 2; // Avoid divide by 0
    if (trB >= trD)  trB = 0;   // Ensure trB < trD
    for (i = UMV_MIN; i <= UMV_MAX; ++i) {
        tabMvF[i] = (trB * i) / trD;          // Mv using prev. picture
        tabMvB[i] = ((trB - trD) * i) / trD;  // Mv using new P-picture
    }
}


// Tables for B-picture: Bquant and mvF/mvB
static U8   tabBquant[QUANT_MAX-QUANT_MIN+1];
static int  decMvF[UMV_MAX-UMV_MIN+1],  // Mv using prev. picture
            decMvB[UMV_MAX-UMV_MIN+1];  // Mv using new P-picture

//  initPBtabs - Initialize tables for Bquant and mvB/mvF
static void initPBtabs( PICTURE_DESCR * pic )
{
    int i, n;

    // Generate tables for B-picture motion vectors
    InitMvTabs( (pic->tr - pic->trPrev) & H263_TR_MASK, 
                pic->tempRefBframe,
                &decMvF[-UMV_MIN], &decMvB[-UMV_MIN] );
    // Generate table for Bquant
    n = pic->dbQuant + 5;
    for (i = QUANT_MIN; i <= QUANT_MAX; ++i) {
        tabBquant[i - QUANT_MIN] = min( (n*i) >> 2, QUANT_MAX );
    }
}


//  DecGobLayer263 - Decode H.263 GOB Layer information
extern int  DecGobLayer263( BS_PTR * bs, int nbits, GOB_DESCR * gob, int * gfid )
{
    int     gn, quant;

    // Decode GN
    if (FLDecSymbol( bs, 5, &nbits, &gn )  !=  OK)  return( OUT_OF_BITS );
    // Decode GFID
    if (FLDecSymbol( bs, 2, &nbits, gfid )  !=  OK)  return( OUT_OF_BITS );
    // Decode GQUANT
    if (FLDecSymbol( bs, 5, &nbits, &quant )  !=  OK)  return( OUT_OF_BITS );
    if (quant < QUANT_MIN  ||  quant > QUANT_MAX)  return( H261_ERROR );
    gob->gquant = quant;
    // Indicate that GOB header has no "spares"
    gob->gei = 0;
    gob->num_gspare = 0;
    return( OK );
}

//#define DB_DUMP_BLOCK_SYMBOLS
#ifdef DB_DUMP_BLOCK_SYMBOLS
FILE * pDecFile=0;
int bDecOpen=0;
int bDecClose=0;
#ifdef WIN32
#define DB_DUMP_FNAME "C:\\temp\\dec_out.dmp"
#define DB_DUMP_FMODE "wt"
#else
#define DB_DUMP_FNAME "/tmp/dec_out.dmp"
#define DB_DUMP_FMODE "w"
#endif
#endif

//  DecMbLayer263 - Decode macroblock layer and block layer for a Group Of Blocks
//  This routine is very picky when determining whether bitstream is valid.
//  It returns OK only if a startcode ends the bitstream; otherwise, it
//  returns H261_ERROR.
//  If rtpFlag is set, we relax the bitstream checking and decode macroblocks
//  until we reach the end of the bitstream or until we have decoded the whole GOB.
extern int  DecMbLayer263(  BS_PTR * bs,    // Bitstream pointer
                            int nbits,      // Bits to decode (incl. trailing startcode)
                            GOB_DESCR * gob,        // GOB descriptor
                            MACROBLOCK_DESCR mb[],  // Packed array of "gob->num_mb" MB descr.
                            int interFrame, // 0: ptype=INTRA, otherwise ptype=INTER
                            int PBframe,    // 0: not PB frame, otherwise PB frame
                            int unrestrictedMv, // 0: -16/+15.5 motion, otherwise +/- 31.5
                            int advancedIntraMode, // 0: off else on
                            SYMBOL sym[],   // symbol array
                            int maxsym,     // size of symbol array
                            int numHorPred, // Use hor pred for first numHorPred MBs
                            int rtpFlag,    // If set (nonzero), decode MBs until we reach
                                            // end of bitstream or have completed the GOB.
                            int *nextMba    // If rtpFlag is set, return MB address where
                                            // decoding should be resumed. Returns zero if
                                            // GOB is completed.  Undefined if rtpFlag=0
                            )
{
    int     quant, isym, mcbpcTab, i, j, status, cbpyTab, intraFlag, horPredOnly, mvX, mvY;
    SYMBOL  s;
    int     mcbpc, modB, cbpB;
    int     saveQuant;
    BS_PTR  saveBs;
    BS_ERR_MSG ( char msg[120] );
    
    isym = 0;
    quant = gob->gquant;
    saveQuant = gob->gquant;
    if (interFrame) {
        mcbpcTab = TAB263_MCBPC_INTER;
    } else {
        mcbpcTab = TAB263_MCBPC_INTRA;
    }
    for (i = 0; i < gob->num_mb; ++i) {
	saveBs = *bs;
	saveQuant = quant;
        // Decode MCBPC
        do {
#ifdef RTP_SUPPORT
            if (rtpFlag && nbits <= 0) {
		if (nbits < 0) {
		    BS_ERR_MSG( printf("DecMbLayer:  nbits went negative; nbits = %d\n", nbits); )
		}
                // Bitstream did not contain whole GOB
                *nextMba = i;   // Return macroblock address
		gob->gquant = quant;
                return OK;
            }
#endif
            status = VLDecSymbol( bs, mcbpcTab, &nbits, &s );
	    
            if (status != OK)  {
		BS_ERR_MSG(fprintf(stderr,"1 %d %d %d\n", rtpFlag, nbits,i);)
		goto error_exit;}
        } while( s.type == SYM_MCBPC_STUFFING );
        mcbpc = s.value;
        mb[i].mtype = mcbpc & 0xfc; // Mask off cbpC (two LSBs)

#ifdef DO_H263_PLUS
        if(advancedIntraMode && 
            (mb[i].mtype == MTYPE263_INTRA || mb[i].mtype == MTYPE263_INTRA_Q)) {
            // Decode INTRA_MODE
            status = VLDecSymbol( bs, TAB263PLUS_INTRA_MODE, &nbits, &s );
			if (status != OK)  {
			    BS_ERR_MSG(fprintf(stderr,"2\n");)
			    goto error_exit;
			}
            mb[i].intra_mode = s.value;
        } else {
            mb[i].intra_mode = ADV_INTRA_PRED_NONE;
        }
#endif
        //printf("DecMbLayer:  x = %d   y = %d   type = %d\n", mb[i].x, mb[i].y, mb[i].mtype );
        if (mb[i].mtype == MTYPE_SKIP) {
            mb[i].mv_x = 0;
            mb[i].mv_y = 0;
        } else {
            if (PBframe) {
                // Decode MODB
#ifdef DO_H263_PLUS
				if(PBframe==H263PLUS_IMPROVED_PBFRAME_MODE) {
					status = VLDecSymbol( bs, TAB263PLUS_MODB, &nbits, &s );
				} else {
					status = VLDecSymbol( bs, TAB263_MODB, &nbits, &s );
				}
#else
				status = VLDecSymbol( bs, TAB263_MODB, &nbits, &s );
#endif
				if (status != OK)  {
				    BS_ERR_MSG(fprintf(stderr,"3\n");)
				    goto error_exit;
				}
                modB = s.value;
                mb[i].modB = modB;
                if (BFRAME_HAS_CBP(&mb[i])) {    // Decode cbpB
                    status = FLDecSymbol( bs, 6, &nbits, &cbpB );
                    if (status != OK)  {
			BS_ERR_MSG(fprintf(stderr,"4\n");)
			goto error_exit;
		    }
                    mb[i].cbpB = cbpB;
                } else {
                    mb[i].cbpB = 0;
                }
            } else {
                mb[i].modB = modB = 0;
            }
            // Decode cbpY
            if (mb[i].mtype == MTYPE263_INTRA  ||  mb[i].mtype == MTYPE263_INTRA_Q) {
                cbpyTab = TAB263_CBPY_INTRA;
            } else {
                cbpyTab = TAB263_CBPY;
            }
            status = VLDecSymbol( bs, cbpyTab, &nbits, &s );
            if (status != OK)  {
		BS_ERR_MSG(fprintf(stderr,"5 err %d\n", status);)
		goto error_exit;
	    }
            mb[i].cbp = (s.value << 2) | (mcbpc & 0x3);
            // Decode DQUANT
            if (mb[i].mtype == MTYPE263_INTER_Q  ||  mb[i].mtype == MTYPE263_INTRA_Q) {
                status = VLDecSymbol( bs, TAB263_DQUANT, &nbits, &s );
                if (status != OK)  {
		    BS_ERR_MSG(fprintf(stderr,"6\n");)
		    goto error_exit;
		}
                mb[i].dquant = s.value;
                quant += mb[i].dquant;
                if (quant < QUANT_MIN)
                    quant = QUANT_MIN;
                if (quant > QUANT_MAX)
                    quant = QUANT_MAX;
            }
            mb[i].quant = quant;
            // Decode motion vectors and block layer
            if (i < numHorPred) {
                horPredOnly = YES;  // First row of macroblocks; don't use prev. row
            } else {
                horPredOnly = NO;
            }
            switch( mb[i].mtype ) {
                
            case MTYPE263_INTRA:
            case MTYPE263_INTRA_Q:
                if (PBframe) {  // Decode MVD
                    status = decMvd( bs, &nbits, 1, &mb[i].mvd_x, &mb[i].mvd_y );
                    if (status != OK)  {
			BS_ERR_MSG(fprintf(stderr,"7\n");)
			goto error_exit;
		    }
                    MvPred( &mb[i], WHOLE_MACROBLOCK, gob->mb_offset, horPredOnly, &mvX, &mvY );
                    mb[i].mv_x = getMvComp( mvX, mb[i].mvd_x, unrestrictedMv );
                    mb[i].mv_y = getMvComp( mvY, mb[i].mvd_y, unrestrictedMv );
                    if (BFRAME_HAS_MOTION_VECTOR(&mb[i])) {  // Decode MVDB
                        status = decMvd( bs, &nbits, 1, &mb[i].mvdB_x, &mb[i].mvdB_y );
                        if (status != OK)  {
			    BS_ERR_MSG(fprintf(stderr,"8\n");)
			    goto error_exit;
			}
                    }
                } else {
                    mb[i].mv_x = 0;
                    mb[i].mv_y = 0;
                }

                intraFlag = YES;
#ifdef DO_H263_PLUS
                status = dec263blocks( bs, &nbits, mb[i].cbp, intraFlag, advancedIntraMode,
                                        mb[i].block, &sym[isym], maxsym - isym );
#else
                status = dec263blocks( bs, &nbits, mb[i].cbp, intraFlag, 0,
                                        mb[i].block, &sym[isym], maxsym - isym );
#endif


#ifdef DB_DUMP_BLOCK_SYMBOLS
                if(bDecClose) {
                    fclose(pDecFile);
                    pDecFile = NULL;
                }
                if(bDecOpen) {
                    pDecFile = fopen(DB_DUMP_FNAME, DB_DUMP_FMODE);
		    bDecOpen = 0;
                }

                if(pDecFile) {
                    int b,s;
                    fprintf(pDecFile, "\n \n Macroblock %d \n \n", i);
                    for(b=0; b<6; b++) {
                        fprintf(pDecFile, "\n Block %d \n", b);
                        for(s=0; s<mb[i].block[b].nsym; s++) {
                            fprintf(pDecFile, "lev = %d  run = %d\n", mb[i].block[b].sym[s].value, mb[i].block[b].sym[s].type);
                        }
                    }
                }
#endif

                if (status == H261_ERROR) {
		    BS_ERR_MSG(fprintf(stderr,"04 %d %d\n", i, nbits);)
                    status = BITSTREAM_ERROR;
                    goto error_exit;
                }
                isym += status;
                break;
                
            case MTYPE263_INTER:
            case MTYPE263_INTER_Q:
                // Decode MVD
                status = decMvd( bs, &nbits, 1, &mb[i].mvd_x, &mb[i].mvd_y );
                if (status != OK)  {
		    BS_ERR_MSG(fprintf(stderr,"9\n");)
		    goto error_exit;
		}
                MvPred( &mb[i], WHOLE_MACROBLOCK, gob->mb_offset, horPredOnly, &mvX, &mvY );
                mb[i].mv_x = getMvComp( mvX, mb[i].mvd_x, unrestrictedMv );
                mb[i].mv_y = getMvComp( mvY, mb[i].mvd_y, unrestrictedMv );
                if (BFRAME_HAS_MOTION_VECTOR(&mb[i])) {  // Decode MVDB
                    status = decMvd( bs, &nbits, 1, &mb[i].mvdB_x, &mb[i].mvdB_y );
                    if (status != OK) {
			BS_ERR_MSG(fprintf(stderr,"10\n");)
			goto error_exit;
		    }
                }
                intraFlag = 0;
                status = dec263blocks( bs, &nbits, mb[i].cbp, intraFlag, 0,
                                        mb[i].block, &sym[isym], maxsym - isym );
                if (status == H261_ERROR) {
		    BS_ERR_MSG(fprintf(stderr,"03\n");)
                    status = BITSTREAM_ERROR;
                    goto error_exit;
                }
                isym += status;
                break;
                
            case MTYPE263_INTER4V:
                // Decode MVD1-4
                status = decMvd( bs, &nbits, 4, mb[i].blkDiffX, mb[i].blkDiffY );
                if (status != OK)  {
		    BS_ERR_MSG(fprintf(stderr,"11\n");)
		    goto error_exit;
		}
                for (j = 0; j < 4; ++j) {
                    MvPred( &mb[i], j, gob->mb_offset, horPredOnly, &mvX, &mvY );
                    mb[i].blkMvX[j] = getMvComp( mvX, mb[i].blkDiffX[j], unrestrictedMv );
                    mb[i].blkMvY[j] = getMvComp( mvY, mb[i].blkDiffY[j], unrestrictedMv );
                }
                if (BFRAME_HAS_MOTION_VECTOR(&mb[i])) {  // Decode MVDB
                    status = decMvd( bs, &nbits, 1, &mb[i].mvdB_x, &mb[i].mvdB_y );
                    if (status != OK) {
			BS_ERR_MSG(fprintf(stderr,"12\n"); )
			goto error_exit;
		    }
                }
                intraFlag = 0;
                status = dec263blocks( bs, &nbits, mb[i].cbp, intraFlag, 0,
                                        mb[i].block, &sym[isym], maxsym - isym );
                if (status == H261_ERROR) {
		    BS_ERR_MSG(fprintf(stderr,"02\n");)
                    status = BITSTREAM_ERROR;
                    goto error_exit;
                }
                isym += status;
                break;
                
            default:
                status = UNKNOWN_MTYPE;
                goto error_exit;
                break;
            }
            
            if (PBframe) {
                // Reconstruct forward and backward mv for B-frame
                GetMvBframe( &mb[i], unrestrictedMv, &decMvF[-UMV_MIN], &decMvB[-UMV_MIN] );
                mb[i].Bquant = tabBquant[quant - QUANT_MIN];
                if (BFRAME_HAS_CBP(&mb[i])) {    // Decode B blocks
                    intraFlag = 0;
                    status = dec263blocks( bs, &nbits, mb[i].cbpB, intraFlag, 0,
                                            mb[i].Bblock, &sym[isym], maxsym - isym );
                    if (status == H261_ERROR) {
			BS_ERR_MSG(fprintf(stderr,"01\n");)
                        status = BITSTREAM_ERROR;
                        goto error_exit;
                    }
                    isym += status;
                }
            }
        }
    }
#ifdef RTP_SUPPORT
    if (rtpFlag) {
        // We have completed this GOB
        *nextMba = 0;   // Start at the beginning of next GOB
	gob->gquant = quant;
        // Remove MB stuffing (if any)
        do {
            saveBs = *bs;
            status = VLDecSymbol( bs, mcbpcTab, &nbits, &s );
        } while( status == OK  &&  s.type == SYM_MCBPC_STUFFING );
        *bs = saveBs;
        return OK;
    }
#else
    // Get rid of compiler warnings
#define UNREF_VAR(x)    (x) = (x);
    UNREF_VAR( rtpFlag )
    UNREF_VAR( nextMba )
    UNREF_VAR( saveBs )
#endif
    //printf("DecMbLayer:  Remove stuffing, then find startcode; nbits = %d\n", nbits);
    do {
        status = VLDecSymbol( bs, mcbpcTab, &nbits, &s );
        //if (status != OK) {fprintf(stderr,"13\n"); goto error_exit;}
    } while( s.type == SYM_MCBPC_STUFFING && status == OK);
    /*if (s.type != SYM_STARTCODE  ||  nbits != 0) {
        status = BITSTREAM_ERROR;
        goto error_exit;
    }*/
    return( OK );

error_exit:
    if (rtpFlag) {
	*nextMba = i;
	gob->gquant = quant;
	if (rtpFlag == 2) {
/*
	    fprintf(stderr, "\t\t>>> backing up from %x.%d to %x.%d\n",
				bs->byteptr, bs->bitptr,
				saveBs.byteptr, saveBs.bitptr); 
*/
	    *bs = saveBs;	// reposition to beginning of MB that failed
	    gob->gquant = saveQuant;
	}
    }
    BS_ERR_MSG( sprintf( msg, "DecMbLayer263: error %d occurred in block #%d", status, i);
                                H261ErrMsg( msg ); )
    return( H261_ERROR );
}


//  decMvd - Decode "num" motion vectors
static int  decMvd( BS_PTR * bs,    // Bitstream pointer; updated by this routine
                    int * maxBits,  // max bits to decode; updated by this routine
                    int num,        // number of motion vectors to decode
                    S8  x[],        // hor. components decoded by this routine
                    S8  y[]         // vert. components decoded by this routine
                    )
{
    int     i, status;
    SYMBOL  s;
    
    for (i = 0; i < num; ++i) {
        // Decode horizontal component
        status = VLDecSymbol( bs, TAB263_MVD, maxBits, &s );
        if (status != OK)  return( status );
        x[i] = s.value;
        // Decode vertical component
        status = VLDecSymbol( bs, TAB263_MVD, maxBits, &s );
        if (status != OK)  return( status );
        y[i] = s.value;
    }
    return( OK );
}


// getMvComp - Compute mv component in H.263 decoder
static int getMvComp( int pred, S8 diff, int unrestrictedMv )
{
    int output;
    
    output = pred + diff;
    if (unrestrictedMv == 0) {
        while (output < MVD263_MIN) {
            output += MV263_WRAP;
        }
        while (output > MVD263_MAX) {
            output -= MV263_WRAP;
        }
    } else if (pred < UMV_NEG_THRESH) {
        // UMV pred < -15.5: -31.5 <= output <= 0
        if (output < UMV_MIN) {
            output += MV263_WRAP;   // Need only check negative limit, since diff <= 15.5
        }
    } else if (pred > UMV_POS_THRESH  &&  output > UMV_MAX) {
        // UMV pred > 16: 0 <= output <= 31.5
        output -= MV263_WRAP;       // Need only check positive limit, since diff >= -16
    }   // else: Don't need to check for -15.5 <= pred <= 16
    return( output );
}


//  GetMvBframe - Reconstruct forward and backward motion vectors for B-frame
extern void GetMvBframe( MACROBLOCK_DESCR *mb, int unrestrictedMv,
                         int tabMvF[], int tabMvB[]  // [UMV_MIN:UMV_MAX]
                         )
{
    int j;

    if (mb->mtype == MTYPE263_INTER4V) {
        for (j = 0; j < 4; ++j) {
            // Forward prediction (using prev. frame)
            mb->blkMvFx[j] = tabMvF[ mb->blkMvX[j] ];
            mb->blkMvFy[j] = tabMvF[ mb->blkMvY[j] ];
            if (BFRAME_HAS_MOTION_VECTOR(mb)) {
                mb->blkMvFx[j] = getMvComp( mb->blkMvFx[j], mb->mvdB_x, unrestrictedMv );
                mb->blkMvFy[j] = getMvComp( mb->blkMvFy[j], mb->mvdB_y, unrestrictedMv );
                // Backward prediction (using next P-frame)
                mb->blkMvBx[j] = mb->blkMvFx[j] - mb->blkMvX[j];
                mb->blkMvBy[j] = mb->blkMvFy[j] - mb->blkMvY[j];
            } else {
                mb->blkMvBx[j] = tabMvB[ mb->blkMvX[j] ];
                mb->blkMvBy[j] = tabMvB[ mb->blkMvY[j] ];
            }
        }
    } else {    // Same motion vector for the whole macroblock
        // Forward prediction (using prev. frame)
        mb->blkMvFx[0] = tabMvF[ mb->mv_x ];
        mb->blkMvFy[0] = tabMvF[ mb->mv_y ];
        if (BFRAME_HAS_MOTION_VECTOR(mb)) {
            mb->blkMvFx[0] = getMvComp( mb->blkMvFx[0], mb->mvdB_x, unrestrictedMv );
            mb->blkMvFy[0] = getMvComp( mb->blkMvFy[0], mb->mvdB_y, unrestrictedMv );
            // Backward prediction (using next P-frame)
            mb->blkMvBx[0] = mb->blkMvFx[0] - mb->mv_x;
            mb->blkMvBy[0] = mb->blkMvFy[0] - mb->mv_y;
        } else {
            mb->blkMvBx[0] = tabMvB[ mb->mv_x ];
            mb->blkMvBy[0] = tabMvB[ mb->mv_y ];
        }
    }
}


//  dec263blocks - Decode block layer for a macroblock
static int  dec263blocks(   BS_PTR * bs,    // Bitstream pointer; updated by this routine
                            int * maxBits,  // max bits to decode; updated by this routine
                            int cbp,        // Coded Block Pattern
                            int intraFlag,  // 0: INTER block, otherwise INTRA
                            int advancedIntraMode, // 0: off else on
                            BLOCK_DESCR block[6],   // block descriptors generated by this routine
                            SYMBOL sym[],   // array for symbols generated by this routine
                            int maxsym      // size of sym[] array
                            )
{
    int startState, isym, mask, blk, state, status, parsed_bits, nsym;
    
    if (intraFlag) {
#ifdef DO_H263_PLUS
        if(advancedIntraMode) {
            startState = ST263PLUS_BLK_6;
        } else {
            startState = ST263_INTRA_DC_AC;
        }
#else
        startState = ST263_INTRA_DC_AC; // Decode DC and AC coeffs
#endif
    } else {
        startState = ST263_BLK_6;       // Decode one INTER block
    }
    isym = 0;
    mask = 0x20;    // Bit 5 indicates whether first block is coded
    for (blk = 0; blk < 6; ++blk) {
        if (cbp & mask) {
            state = startState;
            status = VLDECODE( *bs, *maxBits, &state, &parsed_bits, 
                                &nsym, &sym[isym], maxsym - isym );
            if ((status != FINISHED_LAST_BLOCK) && (*maxBits != parsed_bits ||
						    parsed_bits <= 0 ||
						    status != OK /*|| sym[isym+nsym-1].type < 64*/))  {
		BS_ERR_MSG(fprintf(stderr, "dec 1 %d\n",blk);)
		return(H261_ERROR );	    
	    }
            IncBsPtr( bs, parsed_bits );
            *maxBits -= parsed_bits;
            status = parseSymbols( &sym[isym], nsym, &sym[isym] );
            if (status == H261_ERROR)  {
		BS_ERR_MSG(fprintf(stderr, "dec 2 %d\n",blk);)
		return( H261_ERROR );
	    }
            block[blk].sym = &sym[isym];
            block[blk].nsym = status;
            isym += status;
        } else if (intraFlag && !advancedIntraMode) { // Decode INTRA-DC
            if (VLDecSymbol( bs, TAB263_INTRA_DC, maxBits, &sym[isym] )  !=  OK) {
		BS_ERR_MSG(fprintf(stderr, "dec 3 %d\n",blk);)
                return( H261_ERROR );
            }
            block[blk].sym = &sym[isym];
            block[blk].nsym = 1;
            ++isym;
        } else {    // No coeffs
            block[blk].nsym = 0;
        }
        mask >>= 1; // Check next block
    }
    return( isym );
}


//  parseSymbols - Merge ESC-RUN and ESC-LEVEL symbols
//  Return number of symbols
static int parseSymbols( SYMBOL insym[],        // Input symbols
                        int nsym,               // # input symbols
                        SYMBOL outsym[]         // output symbols
                        )
{
    int iIn, iOut, zzpos, last = 0, run;
    BS_ERR_MSG ( char msg[120] );
    
    iIn = 0, iOut = 0, zzpos = 0;
    while (iIn < nsym) {
        if (insym[iIn].type == SYM_ESC_RUN) {   // Encountered ESCAPE-LAST-RUN-LEVEL symbol
            last = insym[iIn].value & 0x40;     // LAST is found in bit 6
            run = insym[iIn++].value & 0x3f;    // RUN in bits 0-5
            outsym[iOut].type = run;
            if (checksym( insym[iIn], SYM_ESC_LEVEL, "parseSymbols") != OK) return(H261_ERROR);
            outsym[iOut++].value = insym[iIn++].value;
        } else {
            last = insym[iIn].type & 0x40;      // LAST is found in bit 6
            run = insym[iIn].type & 0x3f;     // RUN in bits 0-5
            outsym[iOut].type = run;
            outsym[iOut++].value = insym[iIn++].value;
        }
        zzpos += run + 1;
        //printf("parseSymbols: "); printsym(outsym[iOut-1 ); printf("   zzpos = %d\n", zzpos);
        if (zzpos > 64) {   // If we decoded coeff. 63, we will now have zzpos=64
            BS_ERR_MSG( sprintf( msg, "parseSymbols: Bitstream error, zzpos=%d", zzpos);
            H261ErrMsg( msg ); )
            return (H261_ERROR);
        }
        if (last != 0  &&  iIn < nsym) {
            H261ErrMsg( "parseSymbols: Encountered LAST=1 prematurely" );
            return (H261_ERROR);
        }
    }
    /*{
        int i;
        static int iprint = YES;
        if (iprint) {
            printf("parseSymbols: Found %d symbols\n", iOut);
            for (i = 0; i < iOut; ++i) {
                printf("Symbol %d:  ", i);
                printsym( outsym[i] );
                printf("\n");
            }
            printf("parseSymbols: Continue printouts? [0/1]: ");
            scanf("%d", &iprint);
        }
    }*/
    if (last != LAST263_RUNVAL  ||  iIn != nsym) {
	// H263-1998 RTP can result in false errors on short blocks
        BS_ERR_MSG( H261ErrMsg( "parseSymbols: Did not find LAST=1" ); )
        return (H261_ERROR);
    }
    return (iOut);
}


#ifdef RTP_SUPPORT

//  ****************************************************
//  H263RtpDecode - Decode one RTP packet with H.263 data
//  ****************************************************
//
#define BAD_PARMS   (-2)
extern int  H263RtpDecode( H261Decoder * s, // Start decoding at s->next_gob/next_mba
                           char * hdr,  // H.263 payload header (defined in RFC2190, Sept'97)
					// or H.263 1998 header (defined in RFC2429, Oct'98)
			   int h263_1998	// 0 = RFC2190, 1 = RFC2429
                           )
{
    int     gn, mba, status, bitsLeft, numBits;
    BS_PTR  bs;
    SYMBOL  sym;
    PICTURE_DESCR   *pic;
    GOB_DESCR       *pGob;

    pic = &s->pic_layer;
    pGob = &s->state.currentGob;
    if (s->codingMethod != H263_CODING) {
        H261ErrMsg("H263RtpDecode: H.263 is the only supported RTP format");
        fprintf(stderr, "RTP 1\n");
        return BAD_PARMS;
    }
    s->maxComp = 0; // Not supporting decoding in "chunks"
    s->pic_layer.decodingInProgress = FALSE;
    // Initialize status
    s->status.dwStartcodes = 0; // # of startcodes processed
    s->status.dwGobs = 0;       // # GOBs processed
    s->status.dwBadgobs = 0;    // # erroneous GOBs
    s->status.dwUpdateGobs = 0; // # GOBs for fast updating
    s->status.dwFirstBadgob = 0;// First bad Gob
    s->status.dwPsc = FALSE;    // indicates that a picture layer was successfully decoded
    s->newBs = s->bsStart;      // Current position in bitstream

    if (s->next_gob == 0  &&  s->next_mba == 0) {
        // Decode Picture Header from bitstream or Payload Header
        if (h263_1998) {
            if (rtpDec1998PicHdr( s, hdr ) != OK){
		//fprintf(stderr, "RTP 2-1998\n");
        	return NO;
	    }
	} else {
            if (rtpDecPicHdr( s, hdr ) != OK){
		fprintf(stderr, "RTP 2\n");
        	return NO;
	    }
	}
	
        // Initialize image structures according to received image format (QCIF, CIF etc.)
        status = InitializePicture ( s );   
        if (status != OK) {
            H261ErrMsg("Decoder: illegal picture format");
	    //fprintf(stderr, "RTP 3\n");
            return NO;
        }
        //s->status.dwIntraFrame = 1;  // Assume intraframe (set to zero if we encounter a non-INTRA MacroBlock)
        s->status.dwIntraFrame = 0; // Unsupported (obsolete?) status flag
    }

    if (h263_1998) {
	// Determine GOB number and MB address from info in packet
	status = getGnMbaFrom1998Packet( s, hdr, &gn, &mba );
	if (status != OK) {        //fprintf(stderr, "RTP 4-1998\n");
	    return NO;}
    } else {
	// Determine GOB number and MB address from info in packet
	status = getGnMbaFromPacket( s, hdr, &gn, &mba );
	if (status != OK) {        //fprintf(stderr, "RTP 4\n");
	    return NO;}
    }

    if (gn > s->next_gob || (gn == s->next_gob && mba > s->next_mba)) {
        // Conceal missing MBs
	status = rtpConceal( s, gn, mba );
	if (status != OK) {        //fprintf(stderr, "RTP 5\n");
	    return NO;}
    }
    // Need to get QUANT/MV from payload header?
    if ((gn != s->next_gob || mba != s->next_mba) && (mba > 0)) {
        status = gobPayloadHdr( s, hdr, gn, mba );
        if (status != OK) {        //fprintf(stderr, "RTP 6\n");
	return NO;}
    }
    s->next_gob = gn, s->next_mba = mba;
    // Decode one GOB at a time
    bitsLeft = BsDiff( s->bsEnd, s->newBs );

    //while ( bitsLeft > 0 ) {
    while ( bitsLeft > 7 ) {    // Ensure more than padding for byte alignment is left (to handle sloppy encoders)
        if (s->next_mba == 0) { // Start a new GOB
            // Create GOB structure
            pGob->mb = s->mb;
            status = Build263gob( pic->format, s->next_gob, s->next_gob+1, pGob, pic );
            if (status != OK) {        //fprintf(stderr, "RTP 7\n");
	    return NO;}
            // Look for GOB startcode
            numBits = bitsLeft;
            bs = s->newBs;
            status = VLDecSymbol( &bs, TAB263_MCBPC_INTRA, &numBits, &sym );
            if (status == OK  &&  sym.type == SYM_STARTCODE) {
                s->state.gobHeader = YES;
                ++s->status.dwStartcodes;
                s->newBs = bs, bitsLeft = numBits;
                // Check GOB number
                status = FLDecSymbol( &bs, 5, &numBits, &gn );  // Decode GN
                if (status != OK  ||  gn != s->next_gob) {        //fprintf(stderr, "RTP 8\n");
		return NO;}
                // Decode GOB layer info
                status = DecGobLayer263( &s->newBs, bitsLeft, pGob, &s->gfid );
                if (status != OK) {        //fprintf(stderr, "RTP 9\n");
		return NO;}
            } else {
                s->state.gobHeader = NO;
            }
        }
        // Try to decode (rest of) GOB
        status = rtpDecMbLayer( s, &mba, h263_1998);
        if (status != OK) {        //fprintf(stderr, "RTP 10\n");
	    if (h263_1998) {
		// Partial Mb encountered, save the beginning for next block
		int nbytes = s->bsEnd.byteptr - s->newBs.byteptr;
		if (nbytes) {
/*
		    fprintf(stderr, "\tsaving %d bytes -- bitptr %d\n",
				nbytes, s->newBs.bitptr); 
*/
		    memcpy(s->bsAbs.byteptr, s->newBs.byteptr, nbytes);
		    s->bsAbs.bitptr = s->newBs.bitptr;
		    s->bsAbsEnd.byteptr = s->bsAbs.byteptr + nbytes;
		    s->bsAbsEnd.bitptr = 0;
		} else {
		    s->bsAbsEnd.byteptr = 0;
		    s->bsAbsEnd.bitptr = 0;
		}
		// Reconstruct decoded MBs
		if (mba > 0)
		    rtpReconGob( s, mba );
		s->next_mba = mba;
	    }
	    return NO;
	}
        // Reconstruct decoded MBs
        rtpReconGob( s, mba );
        // Done with this GOB?
        s->next_mba = mba;
        if (s->next_mba == 0) {
            ++s->next_gob;
            ++s->status.dwGobs;
        }

        if (s->next_gob >= numGobs( pic->format )) {
            // Done with this picture. Discard remaining bits in packet (if any)
            s->next_gob = s->next_mba = 0;
            return YES;
        }
        bitsLeft = BsDiff( s->bsEnd, s->newBs );
    }
    if ( bitsLeft && h263_1998 ) {    // Capture remaining bits in case
	// Partial Mb may be left, save the beginning for next block
	int nbytes = s->bsEnd.byteptr - s->newBs.byteptr;
/*
	fprintf(stderr, "H263RtpDecode: bitsLeft > 0\n");
	fprintf(stderr, "\tsaving %d bytes -- bitptr %d\n",
			nbytes, s->newBs.bitptr); 
*/
	if (nbytes) {
	    memcpy(s->bsAbs.byteptr, s->newBs.byteptr, nbytes);
	} else {
	    *s->bsAbs.byteptr = *s->newBs.byteptr;
	}
	s->bsAbs.bitptr = s->newBs.bitptr;
	s->bsAbsEnd.byteptr = s->bsAbs.byteptr + nbytes;
	s->bsAbsEnd.bitptr = 0;
    }
    fprintf(stderr, "RTP 11\n");
    return NO;  // Not yet done with this picture
}


// H263ConcealRest - Repeat remainder of picture. Call this routine if last bitstream packet
//  for a picture was lost or corrupted to "eject" picture and get ready for a new picture.
extern int  H263ConcealRest( H261Decoder * s    // Start concealment at s->next_gob/next_mba
                           )
{
    int     gn, mba, status;
    PICTURE_DESCR   *pic;
    GOB_DESCR       *pGob;

    pic = &s->pic_layer;
    pGob = &s->state.currentGob;
    if (s->codingMethod != H263_CODING) {
        H261ErrMsg("H263ConcealRest: H.263 is the only supported RTP format");
        return BAD_PARMS;
    }

    if (s->next_gob == 0  &&  s->next_mba == 0) {
        return NO;  // Didn't yet start decoding this picture
    }
    gn = numGobs( pic->format );    // Conceal the rest of the picture
    mba = 0;
    // Conceal remaining MBs
    status = rtpConceal( s, gn, mba );
    if (status != OK) return NO;

    s->next_gob = s->next_mba = 0;  // Expect a new picture
    return YES;
}


// rtpDecPicHdr - Decode Picture Layer info from bitstream or payload header
static int rtpDecPicHdr( H261Decoder * s, char * hdr )
{
    BS_PTR  bs;
    int     numBits, status;
    SYMBOL  sym;
    PICTURE_DESCR   *pic;
    GOB_DESCR       *pGob;

    pic = &s->pic_layer;
    pGob = &s->state.currentGob;
    // Try to decode Picture Header at current bitstream position
    bs = s->newBs;
    numBits = BsDiff( s->bsEnd, bs );
    // Detect startcode
    status = VLDecSymbol( &bs, TAB263_MCBPC_INTRA, &numBits, &sym );
    if (status == OK  &&  sym.type == SYM_STARTCODE) {
        ++s->status.dwStartcodes;
        // Decode rest of Picture Header
        status = DecPicLayer263( &bs, numBits, pic, pGob, &s->ptype );
        // bs gets bumped by DecPicLayer263; now pointing to MB layer
        if (status == OK) {
            s->newBs = bs;  // Point to MB layer
            s->status.dwPsc = TRUE;
        }
    } else {
        status = NO;
    }

    if (status != OK) {
        BS_ERR_MSG( H261ErrMsg( "Bitstream error when decoding Picture Layer" ); )
        // Get Picture Layer info from payload header
        status = picPayloadHdr( s, hdr );
    }
    return status;
}

// rtpDec1998PicHdr - Decode Picture Layer info from bitstream or payload header
static int rtpDec1998PicHdr( H261Decoder * s, char * hdr )
{
    BS_PTR  bs;
    int     numBits, status;
    SYMBOL  sym;
    PICTURE_DESCR   *pic;
    GOB_DESCR       *pGob;

    pic = &s->pic_layer;
    pGob = &s->state.currentGob;
    // Try to decode Picture Header at current bitstream position
    bs = s->newBs;
    numBits = BsDiff( s->bsEnd, bs );
    // Detect startcode
    status = VLDecSymbol( &bs, TAB263_MCBPC_INTRA, &numBits, &sym );
    if (status == OK  &&  sym.type == SYM_STARTCODE) {
        ++s->status.dwStartcodes;
        // Decode rest of Picture Header
        status = DecPicLayer263( &bs, numBits, pic, pGob, &s->ptype );
        // bs gets bumped by DecPicLayer263; now pointing to MB layer
        if (status == OK) {
            s->newBs = bs;  // Point to MB layer
            s->status.dwPsc = TRUE;
        }
    } else {
        status = NO;
    }

    if (status != OK) {
        BS_ERR_MSG( H261ErrMsg( "rtpDec1998PicHdr: Bitstream error when decoding Picture Layer" ); )
        // Get Picture Layer info from payload header
        status = pic1998PayloadHdr( s, hdr );
    }
    return status;
}


// picPayloadHdr - Decode Picture Layer info from payload header
static int picPayloadHdr( H261Decoder * s, char * hdr )
{
    int     flagBit, pbBit, ptype, tr, trb, dbq;
    PICTURE_DESCR   *pic;
    GOB_DESCR       *pGob;

    pic = &s->pic_layer;
    pGob = &s->state.currentGob;
    flagBit = hdr[0] & 0x80;
    pbBit = (hdr[0] & 0x40) >> 6;
    ptype = 0x1000;
    ptype |= hdr[1] & 0xe0; // Source format
    ptype |= pbBit;
    if (flagBit == 0) { // mode A
        ptype |= hdr[1] & 0x1e;
        dbq = (hdr[2] >> 3) & 0x3;
        trb = hdr[2] & 0x7;
        tr = (unsigned int) hdr[3];
        pGob->gquant = QUANT_MIN;   // In case GOB headers are suppressed
    } else {    // mode B/C
        ptype |= (hdr[4] >> 3) & 0x1e;
        if (pbBit) {    // mode C
            dbq = (hdr[10] >> 3) & 0x3;
            trb = hdr[10] & 0x7;
            tr = (unsigned int) hdr[11];
        } else {
            dbq = trb = tr = 0;
        }
        pGob->gquant = hdr[1] & 0x1f;
    }
    pic->tr = tr;
    pic->ptype = ptype;
    pic->splitscreen = pic->doccamera = pic->fp_release = 0;
    switch (ptype & 0xe0)
    {
    case PTYPE263_SQCIF:
        pic->format = SQCIF;
        break;
    case PTYPE263_QCIF:
        pic->format = QCIF;
        break;
    case PTYPE263_CIF:
        pic->format = CIF;
        break;
    case PTYPE263_4CIF:
        pic->format = CIF4;
        break;
    case PTYPE263_16CIF:
        pic->format = CIF16;
        break;
    default:
        return H261_ERROR;
        break;
    }
    pic->interFrame = ptype & PTYPE263_INTER;
    pic->unrestrictedMv = ptype & PTYPE263_UNRESTRICTED_MV;
    pic->advancedPred = ptype & PTYPE263_ADVANCED_PRED;
    pic->syntax_basedAC = ptype & PTYPE263_SYNTAX_BASED_AC;
    if (pic->syntax_basedAC) {
        BS_ERR_MSG( H261ErrMsg("Syntax-based AC not yet supported"); )
        return H261_ERROR;
    }
    pic->PBframeMode = (ptype & PTYPE263_PB_FRAME) != 0;
    pic->reducedResUpdate = 0;
    if(pic->interFrame == 0 && pic->PBframeMode != 0) return H261_ERROR;
    if (pGob->gquant < QUANT_MIN  ||  pGob->gquant > QUANT_MAX)  return H261_ERROR;
    pic->cpm = 0;
    if (pic->PBframeMode) {
        pic->tempRefBframe = trb;
        pic->dbQuant = dbq;
        initPBtabs( pic );  // Generate lookup tables for Bquant and mvB/mvF
    }
    pic->trPrev = pic->tr;  // Hold on to TR for decoding of next picture
    pic->peiCount = 0;
    // Indicate that GOB header has no "spares"
    pGob->gei = 0;
    pGob->num_gspare = 0;
    return OK;
}

// pic1998PayloadHdr - Decode Picture Layer info from H.263+ payload header
static int pic1998PayloadHdr( H261Decoder * s, char * hdr )
{
    int     pBit, vBit, pLen, peBits;
    int     numBits, status;
    BS_PTR  bs;
    PICTURE_DESCR   *pic;
    GOB_DESCR       *pGob;
    char	    *pHdr = hdr + 2;

    //fprintf(stderr, "pic1998PayloadHdr entered\n");
    pic = &s->pic_layer;
    pGob = &s->state.currentGob;

    pBit = hdr[0] & 0x04;
    vBit = hdr[0] & 0x02;
    pLen = ((hdr[0] & 0x01) << 5) | ((hdr[1] & 0xf8) >> 3);
    peBits = hdr[1] & 0x07;
    if (vBit)
	pHdr++;
    if (pLen == 0 || ((pHdr[0] & 0xfc) != 0x80))
	return NO;
    bs.byteptr = (unsigned char *)pHdr;
    bs.bitptr = 1;
    numBits = (pLen * 8) - peBits;
    // Decode rest of Picture Header
    status = DecPicLayer263( &bs, numBits, pic, pGob, &s->ptype );
    // bs gets bumped by DecPicLayer263; now pointing to MB layer
    if (status == OK) {
	s->status.dwPsc = TRUE;
    }
    return status;
}


// getGnMbaFromPacket - Get GOB number and macroblock address from payload header
static int getGnMbaFromPacket( H261Decoder * s, char * hdr, int *gn, int *mba )
{
    BS_PTR  bs;
    int     flagBit, numBits, status;
    SYMBOL  sym;

    flagBit = hdr[0] & 0x80;
    if (flagBit) {  // mode B/C
        // Get start address from payload header
        *gn = (hdr[2] >> 3) & 0x1f;
        *mba = (hdr[2] & 0x7) << 6;     // Upper 3 bits
        *mba |= (hdr[3] >> 2) & 0x3f;   // Lower 6 bits
    } else {    // mode A
        *mba = 0;   // Segmentation on GOB boundary
        // Get GOB number from bitstream
        bs = s->newBs;
        numBits = BsDiff( s->bsEnd, bs );
        // Bitstream starts with GOB header (unless suppressed)
        // Detect GOB startcode
        status = VLDecSymbol( &bs, TAB263_MCBPC_INTRA, &numBits, &sym );
        if (status == OK  &&  sym.type == SYM_STARTCODE) {
            ++s->status.dwStartcodes;
            // Decode GN
            status = FLDecSymbol( &bs, 5, &numBits, gn );
            if (status != OK) return NO;
        } else {
            // Assume suppressed GOB header
            if (s->next_mba != 0) return NO;    // Can't continue w/o GOB header
            *gn = s->next_gob;  // Hope for the best
        }
    }
    return OK;
}

// getGnMbaFrom1998Packet - Get GOB number and macroblock address from payload header
static int getGnMbaFrom1998Packet( H261Decoder * s, char * hdr, int *gn, int *mba )
{
    BS_PTR  bs;
    int     numBits, status;
    SYMBOL  sym;

    *mba = 0;   // Segmentation on GOB boundary
    // Get GOB number from bitstream
    bs = s->newBs;
    numBits = BsDiff( s->bsEnd, bs );
    // Bitstream starts with GOB header (unless suppressed)
    // Detect GOB startcode
    status = VLDecSymbol( &bs, TAB263_MCBPC_INTRA, &numBits, &sym );
    if (status == OK  &&  sym.type == SYM_STARTCODE) {
            ++s->status.dwStartcodes;
            // Decode GN
            status = FLDecSymbol( &bs, 5, &numBits, gn );
/*
	    fprintf(stderr, "getGnMbaFrom1998Packet: gn %d, mba %d\n",
		*gn, s->next_mba);
*/
            if (status != OK) return NO;
    } else {
            // Assume suppressed GOB header
/*
	    fprintf(stderr, "getGnMbaFrom1998Packet: nextgob %d, mba %d\n",
		s->next_gob, s->next_mba);
*/
	    *mba = s->next_mba;
	    *gn = s->next_gob;  // Hope for the best
    }
    return OK;
}


// rtpConceal- Conceal missing MBs from s->next_gob/mba to gn/mba
static int rtpConceal( H261Decoder * s, int gn, int mba )
{
    int gob1, i, status;
    BS_ERR_MSG( char msg[120]; )
    PICTURE_DESCR   *pic;
    GOB_DESCR       *pGob;

    pic = &s->pic_layer;
    pGob = &s->state.currentGob;
    gob1 = s->next_gob;
    for (i = gob1; i <= gn; ++i) {
        // Create GOB structure
        pGob->mb = s->mb;
        status = Build263gob( pic->format, i, i+1, pGob, pic );
        if (status != OK) return NO;
        if (i == gn && mba > 0) {
            // Conceal beginning of first GOB in packet
            pGob->num_mb = mba;
        } else if (i == gn) {
            break;  // Start decoding at the beginning of first GOB
        }
        if (i == gob1 && s->next_mba > 0) {
            // Don't conceal part of GOB that already is decoded
            pGob->num_mb -= s->next_mba;
            pGob->first_col = s->next_mba;
            while (pGob->first_col >= pGob->mb_width) {
                ++pGob->first_row;
                pGob->first_col -= pGob->mb_width;
            }
        }
        ConcealGob( pGob, s->mb, pic->reducedResUpdate, &s->oldOut, &s->newOut );
        if (pic->PBframeMode && s->PBframeCap) {
            // Conceal B-frame
            ConcealGob( pGob, s->mb, pic->reducedResUpdate, &s->oldOut, &s->B_Out );
        }
        ++s->status.dwBadgobs;
        //s->status.dwIntraFrame=0;
        BS_ERR_MSG(
            sprintf( msg, "Bitstream error when decoding GOB %d", i);
            H261ErrMsg( msg ); )
    }
    s->status.dwFirstBadgob = gob1;
    s->status.dwUpdateGobs = gn - gob1;
    if (mba > 0) ++s->status.dwUpdateGobs;

    return OK;
}


// gobPayloadHdr - Get QUANT and MV from payload header
static int gobPayloadHdr( H261Decoder * s, char * hdr, int gn, int mba )
{
    int     flagBit, status;
    S8      mvComp;
    MACROBLOCK_DESCR *prevMb;
    PICTURE_DESCR   *pic;
    GOB_DESCR       *pGob;

    pic = &s->pic_layer;
    pGob = &s->state.currentGob;
    // Create GOB structure
    pGob->mb = s->mb;
    status = Build263gob( pic->format, gn, gn+1, pGob, pic );
    if (status != OK) return NO;
    s->state.gobHeader = YES;   // Use hor. MV prediction
    // Get QUANT and MV from mode B/C payload header
    flagBit = hdr[0] & 0x80;
    prevMb = &pGob->mb[ pGob->first_row * pGob->mb_offset + mba - 1 ];
    if (flagBit) {  // mode B/C (we will not call this routine if mode A,i.e., mba=0)
        pGob->gquant = hdr[1] & 0x1f;
        if (pGob->gquant < QUANT_MIN  ||  pGob->gquant > QUANT_MAX)  return H261_ERROR;
        if (mba > 0) {
            // Be careful with the sign extension on mv components!
            mvComp = (hdr[5] >> 4) & 0xf;
            mvComp |= hdr[4] << 4;
            prevMb->mv_x = prevMb->blkMvX[1] = mvComp >> 1;
            mvComp = (hdr[6] >> 5) & 0x7;
            mvComp |= hdr[5] << 3;
            prevMb->mv_y = prevMb->blkMvY[1] = mvComp >> 1;
            mvComp = (hdr[7] >> 6) &0x3;
            mvComp |= hdr[6] << 2;
            prevMb->blkMvX[3] = mvComp >> 1;
            mvComp = hdr[7] << 1;
            prevMb->blkMvY[3] = mvComp >> 1;
            if (pic->advancedPred &&
                    (prevMb->blkMvX[1] != prevMb->blkMvX[3]  ||
                     prevMb->blkMvY[1] != prevMb->blkMvY[3])) {
                // Set INTER4V mode to ensure correct motion comp (concealment routine
                // sets mtype to SKIP)
                prevMb->mtype = MTYPE263_INTER4V;
            }
        }
    }
    return OK;
}


// rtpDecMbLayer - Try to decode (rest of) GOB
static int rtpDecMbLayer( H261Decoder * s, int *mba, int h263_1998 )
{
    int bitsLeft, status, numHorPred, rtpFlag=1;
    PICTURE_DESCR   *pic;
    GOB_DESCR       *pGob;
    MACROBLOCK_DESCR *mb;

    if (h263_1998)
	rtpFlag = 2;
    pic = &s->pic_layer;
    pGob = &s->state.currentGob;
    bitsLeft = BsDiff( s->bsEnd, s->newBs );
    if (s->state.gobHeader == YES || pGob->first_row == 0) {
        // Use hor. MV pred in first row of MBs (if GOB header)
        numHorPred = pGob->mb_width - s->next_mba;
    } else {
        numHorPred = 0;
    }
    pGob->num_mb -= s->next_mba;    // Fiddle with GOB structure to account for MBA
    mb = s->mb + s->next_mba + pGob->first_col 
                            + pGob->first_row * pGob->mb_offset;
    status = DecMbLayer263( &s->newBs, bitsLeft, pGob,
                            mb,
                            pic->interFrame,
                            pic->PBframeMode,
                            pic->unrestrictedMv,
                            pic->advancedIntraMode,
                            s->sym, s->maxSym, numHorPred, rtpFlag, mba );
    pGob->num_mb += s->next_mba;        // Restore GOB structure
    if (*mba != 0) *mba += s->next_mba; // Total number of MBs decoded in this GOB
    return status;
}


// rtpReconGob - Reconstruct decoded MBs
static void rtpReconGob( H261Decoder * s, int mba )
{
    int saveNumMb, maxComp = 0;
    PICTURE_DESCR   *pic;
    GOB_DESCR       *pGob;

    pic = &s->pic_layer;
    pGob = &s->state.currentGob;
    if (s->next_mba > 0) {
        // Fiddle with state variables to start reconstruction at next_mba
        s->state.i = s->next_mba;
        s->state.mbnum = s->next_mba + pGob->first_col + pGob->first_row * pGob->mb_offset;
        s->state.col = s->next_mba + pGob->first_col;
        while (s->state.col >= pGob->mb_width) {
            s->state.col -= pGob->mb_width;
            s->state.mbnum += pGob->mb_offset - pGob->mb_width;
        }
    } else {
        s->state.i = 0; // Start at the beginning of the GOB
    }
    saveNumMb = pGob->num_mb;
    if (mba > 0) {
        // Did not reach end of GOB
        pGob->num_mb = mba; // Fiddle with GOB structure
    }
    ReconGob( pGob, s->mb, &s->oldOut, &s->newOut, &s->B_Out, 
              pic->advancedPred, pic->PBframeMode, 
              s->PBframeCap, pic->reducedResUpdate, pic->advancedIntraMode,
              &s->state, maxComp );
    // Restore GOB structure
    pGob->num_mb = saveNumMb;
}


// numGobs - Return number of GOBs in picture
static int numGobs( int format )
{
    int nGobs;

    switch ( format )
    {
    case SQCIF:
        nGobs  = 6;
        break;
    case QCIF:
        nGobs  = 9;
        break;
    case CIF:
    case CIF4:
    case CIF16:
        nGobs  = 18;
        break;
    default:
        nGobs  = 0;
        break;
    }
    return nGobs;
}

#endif  /* RTP_SUPPORT */
