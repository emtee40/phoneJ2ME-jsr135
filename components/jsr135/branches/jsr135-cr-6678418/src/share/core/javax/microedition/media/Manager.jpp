/*
 *
 *  Copyright  1990-2007 Sun Microsystems, Inc. All Rights Reserved.
 *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 *  
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License version
 *  2 only, as published by the Free Software Foundation.
 *  
 *  This program is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *  General Public License version 2 for more details (a copy is
 *  included at /legal/license.txt).
 *  
 *  You should have received a copy of the GNU General Public License
 *  version 2 along with this work; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 *  02110-1301 USA
 *  
 *  Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
 *  Clara, CA 95054 or visit www.sun.com if you need additional
 *  information or have any questions.
 */
package javax.microedition.media;

import java.io.IOException;
import java.io.InputStream;

import java.util.Vector;
import java.util.Enumeration;
import java.util.Hashtable;

import com.sun.j2me.log.Logging;
import com.sun.j2me.log.LogChannels;
import com.sun.mmedia.BasicPlayer;
import com.sun.mmedia.PlayerImpl;
import com.sun.mmedia.TonePlayer;
import com.sun.mmedia.Configuration;
import com.sun.mmedia.protocol.*;
import com.sun.mmedia.DefaultConfiguration;
import com.sun.mmedia.DirectPlayer;

// #ifdef USE_RTSP [
import com.sun.mmedia.RTSPPlayer;
// #endif ]

// #ifndef ABB [
import javax.microedition.media.protocol.*;
// #endif ]

/* JAVADOC ELIDED */

public final class Manager {
    // #ifdef ENABLE_DEBUG [
    private final static boolean debug = true;
    // #else ][
    private final static boolean debug = false;
    // #endif ]

    private static Configuration config = Configuration.getConfiguration();
    private static TonePlayer tonePlayer;
    
    /**
     * The locator to create a tone <code>Player</code>
     * to play back tone sequences.  For example,
     * <pre>
     * try {
     *     Player p = Manager.createPlayer(Manager.TONE_DEVICE_LOCATOR);
     *     p.realize();
     *     ToneControl tc = (ToneControl)p.getControl("ToneControl");
     *     tc.setSequence(mySequence);
     *     p.start();
     * } catch (IOException ioe) {
     * } catch (MediaException me) {}
     * </pre>
     *
     * If a tone sequence is not set on the tone
     * <code>Player</code> via its <code>ToneControl</code>,
     * the <code>Player</code> does not carry any
     * sequence.  <code>getDuration</code> returns 0 for this
     * <code>Player</code>.
     * <p>
     * The content type of the <code>Player</code> created from this
     * locator is <code>audio/x-tone-seq</code>.
     * <p>
     * A <code>Player</code> for this locator may not be supported
     * for all implementations.
     * <p>
     * Value "device://tone" is assigned to <code>TONE_DEVICE_LOCATOR</code>.
     */
    public final static String TONE_DEVICE_LOCATOR = "device://tone";

    // #ifndef ABB [
    /**
     * The locator to create a MIDI <code>Player</code>
     * which gives access to the MIDI device by making
     * {@link javax.microedition.media.control.MIDIControl MIDIControl}
     * available.  For example,
     * <pre>
     * try {
     *     Player p = Manager.createPlayer(Manager.MIDI_DEVICE_LOCATOR);
     *     p.prefetch(); // opens the MIDI device
     *     MIDIControl m = (MIDIControl)p.getControl("MIDIControl");
     * } catch (IOException ioe) {
     * } catch (MediaException me) {}
     * </pre>
     *
     * The MIDI <code>Player</code> returned does not carry any
     * media data.  <code>getDuration</code> returns 0 for this
     * <code>Player</code>.
     * <p>
     * The content type of the <code>Player</code> created from this
     * locator is <code>audio/midi</code>.
     * <p>
     * A <code>Player</code> for this locator may not be supported
     * for all implementations.
     * <p>
     * Value "device://midi" is assigned to <code>MIDI_DEVICE_LOCATOR</code>.
     */
    public final static String MIDI_DEVICE_LOCATOR = "device://midi";
    // #endif ]
    
    private static String DS_ERR = "Cannot create a DataSource for: ";
    private static String PL_ERR = "Cannot create a Player for: ";

    /**
     * This private constructor keeps anyone from actually
     * getting a <CODE>Manager</CODE>.
     */
    private Manager() { }


/* JAVADOC ELIDED */
    public static String[] getSupportedContentTypes(String protocol) {
        return config.getSupportedContentTypes(protocol);        
    }


/* JAVADOC ELIDED */
    public static String[] getSupportedProtocols(String content_type) {
        return config.getSupportedProtocols(content_type);
    }


    /**
     * Create a <code>Player</code> from an input locator.
     *
     * @param  locator                       A locator string in URI syntax that describes
     * the media content.
     * @return                               A new <code>Player</code>.
     * @exception  MediaException            Thrown if a <code>Player</code> cannot
     * be created for the given locator.
     * @exception  IOException               Thrown if there was a problem connecting
     * with the source pointed to by the <code>locator</code>.
     */
    public static Player createPlayer(String locator)
         throws IOException, MediaException {
        if (locator == null) {
            throw new IllegalArgumentException();
        }

        String locStr = locator.toLowerCase();
        BasicPlayer p;
        boolean found = false;

        if (debug)
            System.out.println("[mmapi] createPlayer with " + locator);

        /* Verify if Protocol is supported */
        String theProtocol = null;
        int idx = locStr.indexOf(':');

        if (idx != -1) {
            theProtocol = locStr.substring(0, idx);
        } else {
            throw new MediaException("Malformed locator");
        }
        String supportedProtocols[] = getSupportedProtocols(null);
        for (int i = 0; i < supportedProtocols.length && !found; i++) {
            if (theProtocol.equals(supportedProtocols[i])) {
                found = true;
            }
        }

        if (!found) {
            throw new MediaException("Player cannot be created for " + locator + 
                                    " Unsupported protocol " + theProtocol);
        }

        if (locStr.startsWith(DefaultConfiguration.CAPTURE_LOCATOR))
        {
            // separate device & encodings
            int encInd = locator.indexOf('?');
            String encStr = null;
            if (encInd > 0) {
                locStr = locStr.substring(0, encInd);

                idx = locator.indexOf("encoding=");
                if (idx != -1) {
                    encStr = locator.substring(idx+9);
                    if (encStr != null) {
                        idx = encStr.indexOf('&');
                        if (idx > 0) {
                            encStr = encStr.substring(0, idx);
                        }
                        encStr = encStr.toLowerCase();
                    }
                }

            }
            String encodings = null;
            if (locStr.equals(DefaultConfiguration.AUDIO_CAPTURE_LOCATOR)) {
                String supported = System.getProperty("supports.audio.capture");
                encodings = System.getProperty("audio.encodings");
                if (supported == null || supported.equals("false") || encodings == null) {
                    found = false;
                }
            } else if (locStr.equals(DefaultConfiguration.VIDEO_CAPTURE_LOCATOR)) {
                String supported = System.getProperty("supports.video.capture");
                encodings = System.getProperty("video.encodings");
                if (supported == null || supported.equals("false") || encodings == null) {
                    found = false;
                }
            }
            if (encStr != null && encodings != null && encodings.indexOf(encStr) == -1) {
                found = false;
            }
        }

        if (!found) {
            throw new MediaException("Player cannot be created for " + locator);
        }

        DataSource ds = createDataSource(locator);
        Player pp = null;

        try {
            pp = createPlayer(ds);
            SourceStream s = ds.getStreams()[0];
            if (s != null && s.getContentDescriptor() != null) {
                /* verify content type determined by http protocol */
                String type = s.getContentDescriptor().getContentType();
                if (type != null) {
                    String supportedContentTypes[] = getSupportedContentTypes(theProtocol);
                    found = false;
                    if (supportedContentTypes != null) {
                        for(int i=0; i<supportedContentTypes.length && !found; i++) {
                            if (type.equals(supportedContentTypes[i])) {
                                found = true;
                            }
                        }
                    }
                }
                if (!found) {
                    pp.close();
                    throw new MediaException("Player cannot be created for " + locator);
                }
            }

        } catch (MediaException ex) {
            ds.disconnect();
            throw ex;
        } catch (IOException ex) {
            ds.disconnect();
            throw ex;
        }
        return pp;
    }


/* JAVADOC ELIDED */
    public static Player createPlayer(InputStream stream, String type)
         throws IOException, MediaException {

        if (stream == null) {
            throw new IllegalArgumentException();
        }

        if (type == null) {
            throw new MediaException(PL_ERR + "cannot determine the media type");
        }
        
        type = type.toLowerCase();

        // Wrap the input stream with a CommonDS where the input
        // can be handled in a generic way.
        
        CommonDS ds = new CommonDS();
        ds.setInputStream(stream);
        ds.setContentType(type);
        
        try {
            return createPlayer(ds);
        } catch (IOException ex) {
            throw new MediaException(PL_ERR + ex.getMessage());
        }
    }


    /**
     * Play back a tone as specified by a note and its duration.
     * A note is given in the range of 0 to 127 inclusive.  The frequency
     * of the note can be calculated from the following formula:
     * <pre>
     *     SEMITONE_CONST = 17.31234049066755 = 1/(ln(2^(1/12)))
     *     note = ln(freq/8.176)*SEMITONE_CONST
     *     The musical note A = MIDI note 69 (0x45) = 440 Hz.
     * </pre>
     * This call is a non-blocking call. Notice that this method may
     * utilize CPU resources significantly on devices that don't
     * have hardware support for tone generation.
     *
     * @param  note                          Defines the tone of the note as specified by the
     * above formula.
     * @param  duration                      The duration of the tone in milli-seconds.
     * Duration must be positive.
     * @param  volume                        Audio volume range from 0 to 100.  100 represents
     * the maximum
     * volume at the current hardware level.  Setting the volume to a
     * value less
     * than 0 will set the volume to 0.  Setting the volume to greater than
     * 100 will set the volume to 100.
     * @exception  MediaException            Thrown if the tone cannot be played
     * due to a device-related problem.
     */
    public static void playTone(int note, int duration, int volume)
         throws MediaException {
             
        if (note < 0 || note > 127 || duration <= 0) {
            if (debug) {
                Logging.report(Logging.ERROR, LogChannels.LC_MMAPI,
                    "playTone note(" + note + ") or duration(" +
                                 duration + ") value is invalid");
            }        
            throw new IllegalArgumentException("bad param");
        }

        if (volume < 0) {
            if (debug) {
                Logging.report(Logging.ERROR, LogChannels.LC_MMAPI,
                    "playTone volume is negative value = " + volume);
            }
            volume = 0;
        } else if (volume > 100) {
            if (debug) {
                Logging.report(Logging.ERROR, LogChannels.LC_MMAPI,
                    "playTone volume is too big = " + volume);
            }        
            volume = 100;
        }

        if (duration == 0 || volume == 0) {
            return;
        }

        if (tonePlayer == null) {
            tonePlayer = config.getTonePlayer();
        }
        
        if (tonePlayer != null) {
            tonePlayer.playTone(note, duration, volume);
        } else {
            throw new MediaException("no tone player");
        }
    }

    /**
     * MMAPI full specific methods.
     *
     * @param  source              Description of the Parameter
     * @return                     Description of the Return Value
     * @exception  IOException     Description of the Exception
     * @exception  MediaException  Description of the Exception
     */

    /**
     * Create a <code>Player</code> for a <code>DataSource</code>.
     *
     * @param  source                        The <CODE>DataSource</CODE> that provides
     * the media content.
     * @return                               A new <code>Player</code>.
     * @exception  MediaException            Thrown if a <code>Player</code> cannot
     * be created for the given <code>DataSource</code>.
     * @exception  IOException               Thrown if there was a problem connecting
     * with the source.
     */
    // #ifndef ABB [
    public static Player createPlayer(DataSource source)
    // #else ][
    private static Player createPlayer(DataSource source)
    // #endif ]
         throws IOException, MediaException {
        if (source == null) {
            throw new IllegalArgumentException();
        }

        String type = source.getContentType();
        if (type != null) {
            String theProtocol = null;
            String locator = source.getLocator();
            if (locator != null) {
                int idx = locator.indexOf(':');
                if (idx != -1) {
                    theProtocol = locator.substring(0, idx);
                }
            }
            String supportedContentTypes[] = getSupportedContentTypes(theProtocol);
            boolean found = false;
            for(int i=0; i<supportedContentTypes.length && !found; i++) {
                if (type.equals(supportedContentTypes[i])) {
                    found = true;
                }
            }
            if (!found) {
                throw new MediaException("Player cannot be created for " + type);
            }
        }

        PlayerImpl p = new PlayerImpl(source);

        return p;
    }


    /**
     * Create a <code>DataSource</code> for the specified media
     * identified by a locator.  The <code>DataSource</code>
     * returned can be used to read the media data from the input
     * source.
     * <p>
     * The returned data source is <i>connected</i>;
     * <code>DataSource.connect</code> has been invoked.
     * <p>
     * If no suitable <code>DataSource</code> can be found to
     * handle the input, a <CODE>MediaException</CODE>
     * is thrown.
     *
     * @param  locator             The source protocol for the media data.
     * @return                     A connected <CODE>DataSource</CODE>.
     * @exception  MediaException  Thrown if no <CODE>DataSource</CODE>
     * can be found that supports the given protocol as specified by
     * the locator.
     * @exception  IOException     Thrown if there was a problem connecting
     * with the source (e.g. the source media does not exist).
     */
    private static DataSource createDataSource(String locator)
         throws IOException, MediaException {

        String className = config.getHandler(BasicDS.getProtocol(locator));

        if (className == null) {
            throw new MediaException(DS_ERR + locator);
        }

        try {

            // ... Try and instance a DataSource ....
            Class protoClass = Class.forName(className);
            DataSource source = (DataSource) protoClass.newInstance();
            // ... and get it connected ....
            ((BasicDS) source).setLocator(locator);
            if (locator.equals(TONE_DEVICE_LOCATOR)) {
                ((BasicDS) source).setContentType("audio/x-tone-seq");
            } else if (locator.equals(MIDI_DEVICE_LOCATOR)) {
                ((BasicDS) source).setContentType("audio/midi");
            }
            return source;
        } catch (MediaException e) {
            throw e;
        } catch (Exception e) {
            throw new MediaException(DS_ERR + e.getMessage());
        }
    }

    // #ifndef ABB [
    private static TimeBase sysTimeBase = null;

    /**
     * Get the time-base object for the system.
     *
     * @return    The system time base.
     */
    public static TimeBase getSystemTimeBase() {
        if (sysTimeBase == null) {
            sysTimeBase = new SystemTimeBase();
        }

        return sysTimeBase;
    }
    // #endif ]
}

// #ifndef ABB [

/**
 * SystemTimeBase is the implementation of the default <CODE>TimeBase</CODE>
 * based on the system clock.
 *
 * @see        TimeBase
 */
class SystemTimeBase implements TimeBase {
    /*
     *  Pick some offset (start-up time) so the system time won't be
     *  so huge.  The huge numbers overflow floating point operations
     *  in some cases.
     */
    private static long offset = System.currentTimeMillis() * 1000L;

    /**
     * This is a straight-forward implementation of a
     * system time base using the system clock.
     *
     * @return    The time value
     */
    public long getTime() {
        return (System.currentTimeMillis() * 1000L) - offset;
    }
}

// #endif ]

